<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>笔记</title>
  <!-- <link rel="stylesheet" href="lib/css/monokai-sublime.css"> -->
  <link rel="stylesheet" href="lib/css/default.min.css">
  <link rel="stylesheet" href="lib/css/vs2015.css">
  <link rel="stylesheet" href="lib/css/zTreeStyle/zTreeStyle.css">
  <link rel="stylesheet" href="lib/css/base.css">
  <link rel="stylesheet" href="lib/css/index.css">
</head>

<body>
  <div style='width:25%;'>
    <ul id="tree" class="ztree" style='width:100%'>

    </ul>
  </div>
  <div id='readme' style='width:70%;margin-left:20%;'>
    <article class='markdown-body'><h1 id="vue-">vue指令</h1>
<h2 id="-">按键修饰符</h2>
<p>在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符： </p>
<pre><code class="lang-js">.enter
.tab
.delete (捕获“删除”和“退格”键)
.esc
.space
.up
.down
.left
.right
</code></pre>
<h2 id="v-if-v-show">v-if 和 v-show</h2>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/conditional.html">条件渲染</a></li>
<li><code>v-if</code>：根据表达式的值的真假条件，销毁或重建元素</li>
<li><code>v-show</code>：根据表达式之真假值，切换元素的 display CSS 属性</li>
</ul>
<pre><code class="lang-html">&lt;p v-show=&quot;isShow&quot;&gt;这个元素展示出来了吗？？？&lt;/p&gt;
&lt;p v-if=&quot;isShow&quot;&gt;这个元素，在HTML结构中吗？？？&lt;/p&gt;
</code></pre>
<h2 id="-class-style">样式处理-class和style</h2>
<ul>
<li>使用方式：<code>v-bind:class=&quot;expression&quot;</code> or <code>:class=&quot;expression&quot;</code></li>
<li>表达式的类型：字符串、数组、对象（重点）</li>
<li>语法：</li>
</ul>
<pre><code class="lang-html">&lt;!-- 1 --&gt;
&lt;!-- 重点 --&gt;
&lt;div v-bind:class=&quot;{ active: true }&quot;&gt;&lt;/div&gt; ===&gt;
&lt;div class=&quot;active&quot;&gt;&lt;/div&gt;

&lt;!-- 2 --&gt;
&lt;div :class=&quot;[&#39;active&#39;, &#39;text-danger&#39;]&quot;&gt;&lt;/div&gt; ===&gt;
&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;

&lt;!-- 3 --&gt;
&lt;div v-bind:class=&quot;[{ active: true }, errorClass]&quot;&gt;&lt;/div&gt; ===&gt;
&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;


--- style ---
&lt;!-- 1 --&gt;
&lt;div v-bind:style=&quot;{ color: activeColor, &#39;font-size&#39;: fontSize + &#39;px&#39; }&quot;&gt;&lt;/div&gt;
&lt;!-- 2 将多个 样式对象 应用到一个元素上--&gt;
&lt;!-- baseStyles 和 overridingStyles 都是对象 --&gt;
&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;
</code></pre>
<h2 id="-v-pre">提升性能：v-pre</h2>
<ul>
<li>说明：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li>
</ul>
<pre><code class="lang-html">&lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;
</code></pre>
<h2 id="-v-once">提升性能：v-once</h2>
<ul>
<li>说明：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li>
</ul>
<pre><code class="lang-html">&lt;span v-once&gt;This will never change: {{msg}}&lt;/span&gt;
</code></pre>
<h2 id="-">案例：品牌管理</h2>
<h1 id="-filter">过滤器 filter</h1>
<ul>
<li>作用：文本数据格式化</li>
<li>两种过滤器：1 全局过滤器 2 局部过滤器</li>
</ul>
<h2 id="-">全局过滤器</h2>
<ul>
<li>说明：通过全局方式创建的过滤器，在任何一个vue实例中都可以使用</li>
</ul>
<pre><code class="lang-js">Vue.filter(&#39;filterName&#39;, function(value) {
  // value 表示要过滤的内容
})
</code></pre>
<ul>
<li>示例：</li>
</ul>
<pre><code class="lang-html">&lt;div&gt;{{ dateStr | date }}&lt;/div&gt;
&lt;div&gt;{{ dateStr | date(&#39;YYYY-MM-DD hh:mm:ss&#39;) }}&lt;/div&gt;

&lt;script&gt;
  Vue.filter(&#39;date&#39;, function(value, format) {
    // value 要过滤的字符串内容
    // format 过滤器的参数
  })
&lt;/script&gt;
</code></pre>
<h2 id="-">局部过滤器</h2>
<ul>
<li>说明：局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用</li>
</ul>
<pre><code class="lang-js">{
  data: {},
  // 通过 filters 属性创建局部过滤器
  filters: {
    filterName: function(value) {}
  }
}
</code></pre>
<h2 id="-">品牌案例-日期格式化</h2>
<h1 id="-">计算属性</h1>
<h2 id="-watch">监视数据变化 - watch</h2>
<ul>
<li>概述：<code>watch</code>是一个对象，键是需要观察的表达式，值是对应回调函数。</li>
<li>作用：当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</li>
</ul>
<pre><code class="lang-js">// 监视数据的变化
watch: {
    //newVal: 变化后的数据  
    //oldVal: 变化前的数据
    msg: function(newVal, oldVal) {
        console.log(&#39;监视了msg的数据变化&#39;, newVal, oldVal)
    }
}
</code></pre>
<ul>
<li>监视对象数据的变化</li>
</ul>
<pre><code class="lang-js">// 监视数据的变化
watch: {
    // watch的完整写法
    car: {
        handler: function(newVal, oldVal) {
            // handler会在数据发生改变的时候触发
            console.log(newVal)
        },
        deep: true,  //是否深度监听
        immediate: true // 在监视启动的时候，会立即启动这个函数
    }
}
</code></pre>
<h2 id="-">计算属性</h2>
<ul>
<li>说明：计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值</li>
<li>注意：Mustache语法（{{}}）中不要放入太多的逻辑，否则会让模板过重、难以理解和维护</li>
<li>注意：<code>computed</code>中的属性不能与<code>data</code>中的属性同名</li>
</ul>
<pre><code class="lang-js">var vm = new Vue({
  el: &#39;#app&#39;,
  data: {
    firstname: &#39;jack&#39;,
    lastname: &#39;rose&#39;
  },
  computed: {
    fullname() {
      return this.firstname + &#39;.&#39; + this.lastname
    }
  }
})
</code></pre>
<p>当计算属性依赖的属性值发生改变的时候，计算属性对应的函数就会重新计算，并且把值缓存起来，直到下一次重新计算，因此计算属性的效率是非常高的。</p>
<h2 id="-">品牌管理案例-筛选功能</h2>
<h1 id="-">生命周期</h1>
<h2 id="-">生命周期介绍</h2>
<ul>
<li><a href="https://cn.vuejs.org/v2/api/#选项-生命周期钩子">vue生命周期钩子函数</a></li>
<li>简单说：<strong>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期</strong></li>
</ul>
<p>组件生命周期函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，那么这些事件，统称为组件的生命周期函数！</p>
<ul>
<li>生命周期的钩子函数：框架提供的函数，能够让开发人员的代码，参与到组件的生命周期中。也就是说，通过钩子函数，就可以控制组件的行为</li>
<li>注意：vue再执行过程中会自动调用<code>生命周期钩子函数</code>，我们只需要提供这些钩子函数即可</li>
<li>注意：钩子函数的名称都是固定的！！！</li>
</ul>
<h2 id="-beforecreate-">钩子函数 - beforeCreate()</h2>
<ul>
<li>说明：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li>
<li>注意：此时，无法获取 data中的数据、methods中的方法</li>
</ul>
<h2 id="-created-">钩子函数 - <strong>created()</strong></h2>
<ul>
<li>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据</li>
<li><a href="https://segmentfault.com/a/1190000008879966">vue实例生命周期 参考1</a></li>
<li><a href="https://segmentfault.com/a/1190000008010666">vue实例生命周期 参考2</a></li>
<li>使用场景：发送请求获取数据</li>
</ul>
<h2 id="-beforemounted-">钩子函数 - beforeMounted()</h2>
<ul>
<li>说明：在挂载开始之前被调用</li>
</ul>
<h2 id="-mounted-">钩子函数 - <strong>mounted()</strong></h2>
<ul>
<li>说明：此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</li>
</ul>
<h2 id="-beforeupdated-">钩子函数 - beforeUpdated()</h2>
<ul>
<li>说明：数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</li>
</ul>
<h2 id="-updated-">钩子函数 - updated()</h2>
<ul>
<li>说明：组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li>
</ul>
<h2 id="-beforedestroy-">钩子函数 - beforeDestroy()</h2>
<ul>
<li>说明：实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li>
</ul>
<h2 id="-destroyed-">钩子函数 - destroyed()</h2>
<ul>
<li>说明：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ul>
</article>
  </div>
</body>
</html>
<script type="text/javascript" src="lib/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="lib/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="lib/js/ztree_toc.min.js"></script>
<script type="text/javascript" src="lib/js/toc_conf.js"></script>
<script src="lib/js/highlight.min.js"></script>
<script>
  $(document).ready(function () {
    // 代码高亮的js代码
    hljs.initHighlightingOnLoad();

    //生成侧边栏的代码
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</script>