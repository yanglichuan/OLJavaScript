# vue组件

## props是只读的

props属性是只读的，子组件中不允许修改父组件中的数据



## 父组件到子组件

- 方式：通过`props`属性来传递数据
- 注意：属性的值必须在组件中通过`props`属性显示指定，否则，不会生效
- 说明：传递过来的`props`属性的用法与`data`属性的用法相同

```html
<hello msg="120"></hello>
<hello my-msg="'abc'"></hello>

<!-- js -->
<script>
  components: {
    hello: {
      // 显式创建props及其传递过来的属性
      props: ['msg', 'myMsg'],
      template: '<h1>这是 hello 组件，这是消息：{{msg}} --- {{myMsg}}</h1>'
    }
  }
</script>
```

## 子组件到父组件

- 方式：父组件给子组件传递一个函数，由子组件调用这个函数
- 说明：借助vue中的自定义事件（v-on:cunstomFn="fn"）
- `$emit()`：触发事件

```html
<hello @pfn="parentFn"></hello>

<script>
  new Vue({
    methods: {
      // 父组件：提供方法
      parentFn(data) {
        console.log('父组件：', data)
      }
    }
  })

  Vue.component('hello', {
    template: '<button @click="fn">按钮</button>',
    methods: {
      // 子组件：通过$emit调用
      fn() {
        this.$emit('pfn', '这是子组件传递给父组件的数据')
      }
    }
  })
</script>
```

## 非父子组件通讯

> 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线

- `$on()`：绑定事件

```js
var bus = new Vue()

// 触发组件 A 中的事件
bus.$emit('id-selected', 1)

// 在组件 B 创建的钩子中监听事件
bus.$on('id-selected', function (id) {
  // ...
})
```

- 示例：组件A ---> 组件B

```html
<!-- 组件A： -->
<com-a></com-a>
<!-- 组件B： -->
<com-b></com-b>

<script>
  var bus = new Vue()

  var vm = new Vue({
    el: '#app',
    components: {
      comB: {
        template: '<p>组件A告诉我：{{msg}}</p>',
        data() {
          return {
            msg: ''
          }
        },
        created() {
          // 定义事件：
          bus.$on('tellComB', (msg) => {
            this.msg = msg
          })
        }
      },

      comA: {
        template: '<button @click="emitFn">告诉B</button>',
        methods: {
          emitFn() {
            // 调用组件B中定义的事件：
            bus.$emit('tellComB', '土豆土豆我是南瓜')
          }
        }
      }
    }
  })
</script>
```

## 获取组件（或元素） - refs

- 说明：`vm.$refs` 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）
- 使用：在 HTML元素 中，添加`ref`属性，然后在JS中通过`vm.$refs.属性`来获取
- 注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods
- `$refs允许父组件直接快速的获取子组件的数据，使用场景并不多`

```html
<div ref="dv"></div>

<!-- js -->
<script>
  vm.$refs.dv
</script>
```

**通过ref属性可以获取到子组件**

```html
<div id="app">
    <son ref="son"></son>
</div>

<script>
console.log(this.$refs.son)
// 获取子组件的数据和方法
console.log(this.$refs.son.msg)
</script>
```

## 组件-slot插槽

## slot插槽

> 当组件中某一项需要单独定义，那么就应该使用solt 

### 单个slot

> 除非子组件模板包含至少一个 `<slot>` 插口，否则父组件的内容将会被丢弃 ,当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。 

在组件的模版中定义`slot`插槽

```js
Vue.component("modal", {
    template: `
    <div class="modal">
    	<p>温馨提示</p>
    	<div>
    		<slot></slot>
    	</div>
    	<button>关闭</button>
    </div>
`,
});
```

父组件传值

```js
<modal>你确定要退出系统吗？</modal>
<modal>你确定要删除这个内容吗？</modal>
```

### 具名插槽

> 如果一个组件中想使用多个slot那么此时就应该使用具名slot。 

```js
Vue.component("modal", {
    template: `
    <div class="modal">
    <slot name="header"></slot>
    <slot name="content"></slot>
    <slot name="footer"></slot>
    </div>
	`,
});
```

```html
<modal>
    <p slot="header">温馨提示</p>
    <div slot="content">你要删除内容吗</div>
    <button slot="footer">关闭</button>
</modal>
<modal>
    <p slot="header">提示</p>
    <div slot="content">你要删除这条记录吗</div>
    <button slot="footer">开启</button>
</modal>
```







## 动态组件 - component

- 作用：渲染一个“元组件”为动态组件。依 `is` 的值，来决定哪个组件被渲染。

```html
<!-- 动态组件由 vm 实例的属性值 `componentId` 控制 -->
<component :is="componentId"></component>

<script>
// 两个组件：
Vue.component('home', {
  template: '<h1>这是 Home 组件</h1>'
})
Vue.component('login', {
  template: '<h1>这是 Login 组件</h1>'
})

data: {
  componentId: 'home'
}
</script>
```

## vue重点知识回顾

```js
1. 组件定义方式
2. 组件通讯
	父-》子
	子-》父
	非父子 （bus）
```

# 单页应用程序与路由

## SPA -单页应用程序

- SPA： `Single Page Application`

[SPA ](https://baike.baidu.com/item/SPA/17536313?fr=aladdin)

[网易云音乐](https://music.163.com/)

```html
单页Web应用（single page application，SPA），就是只有一个Web页面的应用，
是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。
```

```html
对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面, 需要加载很多资源文件，css js 图片

对于单页应用程序来说, 只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.
  然后, 由页面中js解析获取的数据, 展示在页面中
```

### 优势

- 1 减少了请求体积，加快页面响应速度，降低了对服务器的压力
- 2 更好的用户体验，让用户在web app感受native app的流畅

### 主要技术点

- 1 ajax / axios
- 2 哈希值（锚点）的使用（window.location.hash #）
- 3 hashchange 事件

### 实现思路

- 监听锚点值变化的事件，根据不同的锚点值，请求相应的数据
- 1 锚点（#）原本用作页面内部进行跳转，定位并展示相应的内容
- 2 SPA中，锚点被用作请求不同资源的标识，请求数据并展示内容

## 路由

- 路由即：浏览器URL中的哈希值（# hash）与展示视图内容（template）之间的对应规则
- vue中的路由是：hash 和 component的对应关系，一个哈希值对应一个组件

```html
在 Web app 中，通过一个页面来展示和管理整个应用的功能。
SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！
简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。
当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容
```

### 基本使用

- 安装：`npm i -S vue-router`

```html
<div id="app">
  <!-- 5 路由入口：链接导航 -->
  <router-link to="/home">首页</router-link>
  <router-link to="/login">登录</router-link>

  <!-- 6 路由出口：用来展示匹配路由视图内容 -->
  <router-view></router-view>
</div>

<!-- 1 导入 vue.js -->
<script src="./vue.js"></script>
<!-- 2 导入 路由文件 -->
<script src="./node_modules/vue-router/dist/vue-router.js"></script>
<script>
  // 3 创建两个组件
  const Home = Vue.component('home', {
    template: '<h1>这是 Home 组件</h1>'
  })
  const Login = Vue.component('login', {
    template: '<h1>这是 Login 组件</h1>'
  })

  // 4 创建路由对象
  const router = new VueRouter({
    routes: [
      { path: '/home', component: Home },
      { path: '/login', component: Login }
    ]
  })

  const vm = new Vue({
    el: '#app',
    // 不要忘记，将路由与vue实例关联到一起！
    router
  })
</script>
```

### 重定向

- 解释：将 `/` 重定向到 `/home`

```js
{ path: '/', redirect: '/home' }
```

### 声明式导航与编程式导航



### 路由参数

- 说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理
- 语法：`/user/:id`
- 使用：当匹配到一个路由时，参数值会被设置到 this.$route.params
- 其他：可以通过 `$route.query` 获取到 URL 中的查询字符串（queryString） 等

```js
// 链接：
<router-link to="/user/1001">用户 Jack</router-link>
<router-link to="/user/1002">用户 Rose</router-link>

// 路由：
{ path: '/user/:id', component: User }

// User组件：
const User = {
  template: `<div>User {{ $route.params.id }}</div>`
}
```

# vue过渡动画

> vue适合做增删改查，不适合做特别炫酷的动态效果，但是在网页中常见的显示隐藏动画也是非常普遍的。在vue中支持多种方式进行动画

Vue 提供了 `transition` 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 

```html
<transition name="slide">
    <p v-show="isShow">{{msg}}</p>
</transition>
```

## vue动画-类名

> 在进入/离开的过渡中，会有 6 个 class 切换。 

![](E:/cursor/24-SH23/16-vue%E7%AC%AC%E5%9B%9B%E5%A4%A9/01-%E6%95%99%E5%AD%A6%E8%B5%84%E6%96%99/%E7%AC%94%E8%AE%B0/imgs/transition.png)



```css
.slide-enter {
    transform: translateX(-300px);
}
.slide-enter-to {
    transform: translateX(0px);
}
.slide-enter-active {
    transition: all 1s linear;
}
.slide-leave {
    transform: translateX(0px);
}
.slide-leave-to {
    transform: translateX(300px);
}
.slide-leave-active {
    transition: all 1s linear;
}
```

## vue动画-animate.css

- 安装

```html
npm i animate.css
```

- 引入

```css
  <link rel="stylesheet" href="./node_modules/animate.css/animate.css">
```

- 使用

```html
<transition name="slide" enter-active-class="animated bounceInLeft"
            leave-active-class="animated bounceOutRight">
    <p v-show="isShow">{{msg}}</p>
</transition>
```



