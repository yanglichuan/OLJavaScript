# 01-教学反馈

# 02-复习-表格的属性与分页的属性

# 03-slot-scope的原理-作用域插槽

[插槽](https://cn.vuejs.org/v2/guide/components-slots.html)

## 单个插槽

组件

```html
    Vue.component('modal', {
      template: `
        <div class="modal">
          <h3>温馨提示</h3>
          <div class="content"><slot></slot></div>
          <button>关闭</button>
        </div>
      `
    })
```

使用

```html
<modal>我希望我的内容是变化的，哈哈</modal>
```

插槽的作用：

+ 如果没有指定插槽，标签中的内容会被忽略掉
+ 如果指定了插槽，标签中的内容会显示在slot中



## 具名插槽

有些时候我们需要多个插槽 ，就应该使用具名插槽

组件

```html
    Vue.component('modal', {
      template: `
        <div class="modal">
          <h3><slot name="tips"></slot></h3>
          <div class="content"><slot name="content"></slot></div>
          <button>关闭</button>
        </div>
      `
    })
```

html页面

```html
<modal>
    <span slot="tips">温馨提示</span>
    <span slot="content">我是内容啊，哈哈哈哈</span>
</modal>
```

## 作用域插槽

官方叫法：作用域插槽，说白了就是带数据的插槽

+ 前面两两种，只需要在组件的template中使用

```html
匿名插槽
<slot></slot>
具名插槽
<slot name="up"></slot>
```

+ 作用域插槽，要求在slot上绑定数据, 子组件提供了数据，父组件可以通过作用域插槽来使用

```html
<slot :list="list">

<div class="modal">
    <div class="content"><slot :list="list"></slot></div>
</div>
      `,
```

+ 在父组件中，可以使用子组件传递的数据

```html
<modal>
    <template slot-scope="scope">
        {{scope.list}}
    </template>
</modal>
<modal>
    <template slot-scope="scope">
        <ul>
            <li v-for="item in scope.list">{{item}}</li>
        </ul>
    </template>
</modal>
```

# 04-ES6语法-解构赋值

> ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 

+ 以前，给变量赋值，只能直接指定

```js
let a = 1;
let b = 2;
let c = 3;
```

- 数组解构赋值

```js
let [a, b, c] = [1,2,3]
相当于
let a = 1
let b = 2
let c = 3

let [bar, foo] = [1];
相当于
let bar = 1
let foo = undefined
```

- 对象解构赋值

```jsx
let { foo, bar } = { foo: "aaa", bar: "bbb" };
// 相当于
let foo = 'aaa'
let bar = 'bbb'

// 解构的使用
let obj = {
    meta: 'aa',
    data: 'bb'
}
let {meta, data} = obj
```

- 修改user列表，使用解构赋值

# 05-将axios添加到vue原型

- 使用axios不爽的地方

```js
1. 每个组件使用的时候，都需要先引入axios
2. 每个接口都需要拼接一个基础的路径
3. 每个接口都需要加上token
```

- 把axios对象放到vue的原型上

```js
// 引入axios
import axios from 'axios'

// 把axios绑定到Vue的原型上即可
Vue.prototype.axios = axios
```

- 修改User.vue和Login.vue中的axios代码

```js
this.axios({})
```

# 06-axios全局配置

- [axios中文文档](https://www.kancloud.cn/yunye/axios/234845)
- axios的baseUrl参数

```js
// baseURL会自动拼接上url参数
baseURL: 'http://localhost:8888/api/private/v1/',
url: 'users',
```

- 配置公共的baseURL

```js
// 配置axios的baseURL
axios.defaults.baseURL = 'http://localhost:8888/api/private/v1/'
```

- 配置默认headers

```js
axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;
```

# 07-axios拦截器

```js
// 添加请求拦截器
axios.interceptors.request.use(function (config) {
  // 在发送请求之前做些什么
  config.baseURL = 'http://localhost:8888/api/private/v1/'
  config.headers.Authorization = localStorage.getItem('myToken')
  return config
}, function (error) {
  // 对请求错误做些什么
  return Promise.reject(error)
})
```

# 08-User组件-启用禁用状态

- 注册事件

```html
<el-switch
           v-model="scope.row.mg_state"
           active-color="#13ce66"
           inactive-color="#ff4949"
           @change="changeState">
</el-switch>
```

- 事件处理程序

```js
// 改变状态
changeState (user) {
    // 发送ajax请求
    this.axios.put('users/' + user.id + '/state/' + user.mg_state).then(res => {
        const {meta} = res.data
        if (meta.status === 200) {
            this.$message.success('修改状态成功')
        } else {
            this.$message.error('修改状态失败')
        }
    })
}
```

+ 使用模板字符串

```js
// 使用字符串模板解决拼串的烦恼
`users/${user.id}/state/${user.mg_state}`
```

# 09-删除用户

- 给删除用户注册点击事件

```js
<el-button type="danger" size="small" plain icon="el-icon-delete" @click="deleteUser(scope.row)"></el-button>
```

- 准备deleteUser方法

```js
deleteUser (user) {
	console.log(user)
}
```

- 显示模态框

```js
// 1. 显示模态框
this.$confirm('你确定要删除该用户吗?', '温馨提示', {
    confirmButtonText: '确定',
    cancelButtonText: '取消',
    type: 'warning'
}).then(() => {
    this.$message({
        type: 'success',
        message: '删除成功!'
    })
}).catch(() => {
    this.$message({
        type: 'info',
        message: '已取消删除'
    })
})
```

- 点击确定时，发送ajax请求

```js
// 2.发送ajax请求
this.axios.delete(`users/${user.id}`).then(res => {
    const {meta} = res.data
    if (meta.status === 200) {
        this.$message.success('删除数据成功了')
        // 重新获取当前页的数据
        this.getUserList()
    }
})
```

- 解决只剩下一条数据时的bug

```js
// 解决只剩下一条数据时的bug
if (this.userList.length === 1) {
    // 如果只有一条数据的话，需要让当前页减1
    this.current--
}
```

# 10-添加用户-显示对话框

+ 给添加按钮注册点击事件

```js
<el-button type="success" plain @click="showAddDialog">添加用户</el-button>
```

+ 准备showAddModal方法

```js
// 显示添加用户的对话框
showAddDialog () {

}
```

+ 显示对话框

[Dialog 对话框](http://element-cn.eleme.io/#/zh-CN/component/dialog)

```html
<!-- visible: 是否显示 -->
<el-dialog
           title="提示"
           :visible.sync="addDialogVisible"
           width="40%">
    <span>这是一段信息</span>
    <span slot="footer" class="dialog-footer">
        <el-button @click="addDialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="addUser">确 定</el-button>
    </span>
</el-dialog>
```

+ 在data中准备数据

```js
addDialogVisible: false, // 添加对话框，默认不显示
```

+ 准备addUser方法

```js
addUser () {
    
}
```

+ 显示对话框

```js
// 显示添加用户的对话框
showAddDialog () {
	this.addDialogVisible = true
}
```

# 11-添加数据-准备表单

+ 在form组件中找到`自定义校验规则`的表单

```html
<el-form :model="addForm" status-icon :rules="rules2" ref="addForm" label-width="100px" class="addForm">
    <el-form-item label="密码" prop="pass">
        <el-input type="password" v-model="ruleForm2.pass" auto-complete="off"></el-input>
    </el-form-item>
    <el-form-item label="确认密码" prop="checkPass">
        <el-input type="password" v-model="ruleForm2.checkPass" auto-complete="off"></el-input>
    </el-form-item>
    <el-form-item label="年龄" prop="age">
        <el-input v-model.number="ruleForm2.age"></el-input>
    </el-form-item>
    <el-form-item>
        <el-button type="primary" @click="submitForm('ruleForm2')">提交</el-button>
        <el-button @click="resetForm('ruleForm2')">重置</el-button>
    </el-form-item>
</el-form>
```

+ 修改成添加用户的表单

```html
<el-form :model="addForm" status-icon :rules="addRules" ref="addForm" label-width="100px" class="addForm">
    <el-form-item label="用户名" prop="username">
        <el-input type="text" v-model="addForm.username" auto-complete="off"></el-input>
    </el-form-item>
    <el-form-item label="密码" prop="password">
        <el-input type="text" v-model="addForm.password" auto-complete="off"></el-input>
    </el-form-item>
    <el-form-item label="邮箱" prop="email">
        <el-input v-model.number="addForm.email"></el-input>
    </el-form-item>
    <el-form-item label="手机号" prop="mobile	">
        <el-input v-model.number="addForm.mobile"></el-input>
    </el-form-item>
</el-form>
```

+ data中准备数据

```json
addForm: { // 添加数据的对象
    username: '',
    password: '',
    email: '',
    mobile: ''
},
```

+ 准备校验规则

```json
addRules: { // 添加用户的校验规则
    username: [
        { required: true, message: '请输入用户名', trigger: 'change' },
        { min: 3, max: 6, message: '长度在 3 到 6 个字符', trigger: 'change' }
    ],
    password: [
        { required: true, message: '请输入密码', trigger: 'change' },
        { min: 6, max: 12, message: '长度在 6 到 12 个字符', trigger: 'change' }
    ],
    email: [
        { required: true, message: '请输入邮箱', trigger: 'change' },
        { pattern : /^\w+@\w+\.\w+$/, message: '请输入正确的邮箱', trigger: 'change' }
    ],
    mobile: [
        { required: true, message: '请输入手机号', trigger: 'change' },
        { pattern : /^1\d{10}$/, message: '请输入正确的手机号', trigger: 'change' }
    ]
},
```

# 12-添加数据-添加功能完成

+ 表单添加功能

```js
// 表单校验
this.$refs.addForm.validate(valid => {
    if (valid) {
        console.log('校验成功')
    } else {
        console.log('校验失败')
        return false
    }
})
```

+ 发送ajax请求，添加数据

```js
// 发送ajax请求，添加数据
this.axios.post('users', this.addForm).then(res => {
    const {meta, data} = res.data
    if (meta.status === 201) {
        // 创建成功
        console.log('创建成功了')
    }
})
```

+ 添加数据成功后的处理

```js
if (meta.status === 201) {
    // 隐藏模块框
    this.addDialogVisible = false
    // 清空样式
    this.$refs.addForm.resetFields()
    // 重新渲染
    this.getUserList()
    // 提示添加成功
    this.$message.success('用户添加成功了')
}
```

+ 解决bug，如何显示最后一页

```js
// 让current显示为最后一页
this.total++
this.current = Math.ceil(this.total / this.pageSize)
```

+ 解决bug，用户名重复的问题

```js
else {
    this.$message.error('用户名已经存在了')
}
```

# 13-编辑用户-编辑对话框

+ 给编辑按钮注册点击事件

```html
<el-button type="primary" plain size="small" @click='showEditModal'  icon="el-icon-edit"></el-button>
```

+ 在methods中增加方法，测试事件是否注册上

```js
// 展示修改模态框
showEditModal () {
    console.log(111)
}
```

+ 复制增加模态框，修改为修改模态框

```html
<el-dialog
           title="提示"
           :visible.sync="editDialogVisible"
           width="40%">
    <el-form
             :model="editForm"
             status-icon
             :rules="addRules"
             ref="editForm"
             label-width="80px"
             class="addForm">
        <el-form-item label="邮箱" prop="email">
            <el-input v-model="editForm.email"></el-input>
        </el-form-item>
        <el-form-item label="手机号" prop="mobile">
            <el-input v-model="editForm.mobile"></el-input>
        </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
        <el-button @click="editDialogVisible = false">取 消</el-button>
        <el-button type="primary" @click="editUser">确 定</el-button>
    </span>
</el-dialog>
```

+ 准备数据

```json
editDialogVisible: false, // 修改对话框，默认不显示
editForm: {
    email: '',
    mobile: ''
},
```

+ 准备方法

```js
    // 显示修改对话框
    showEditDialog () {
      this.editDialogVisible = true
    },
    editUser () {

    }
```

# 14-编辑用户-数据回显

+ 数据回显

```js
// 显示修改对话框
showEditDialog (user) {
    // 显示对话框
    this.editDialogVisible = true
    // 数据回显
    this.editForm.email = user.email
    this.editForm.mobile = user.mobile
    this.editForm.id = user.id
    this.editForm.username = user.username
},
```

+ 显示用户名

```html
<el-form-item label="用户名" prop="email">
    <el-tag type="info">{{editForm.username}}</el-tag>
</el-form-item>
```

# 15-编辑功能-完成

1. 查看接口文档

```js
接口地址：https://shop-api.circle.ink/#10305
```

2. 处理id的问题

```js
//userInfo增加id属性
userInfo: {
    username: '',
    password: '',
    email: '',
    mobile: '',
    id: ''
};
    
// 展示修改模态框
showEditModal (user) {
    this.userInfo.username = user.username
    this.userInfo.email = user.email
    this.userInfo.mobile = user.mobile
    this.userInfo.id = user.id
    this.editFormVisible = true
};
    
// 修改用户的方法
editUser () {
    this.axios.put(`users/${this.userInfo.id}`, this.userInfo).then(res => {
        console.log(res.data)
    })
}
```

3. 修改成功后的处理方法

```js
if (meta.status === 200) {
    // 隐藏模态框
    this.editFormVisible = false
    // 重新渲染
    this.getUserList()

    // 提示成功
    this.$message({
        type: 'success',
        message: '修改成功!'
    })
} else {
    // 提示成功
    this.$message({
        type: 'error',
        message: '修改失败!'
    })
}
```

# 16-ES6-Promise语法-回调地狱

![](callback-hell.jpg)

回调函数：异步操作的时候，需要使用到回调函数

回调地狱：如果有大量的异步操作嵌套，就会形成回调地狱

+ 需求，有四个文件, a.txt b.txt c.txt d.txt，要求按照顺序读取里面的内容

```js
// 这么做无法完成任务，每次打印的顺序都是随机的
const fs = require('fs')

console.log('begin')
fs.readFile('a.txt', 'utf8', (err, data) => {
  console.log(data)
})
fs.readFile('b.txt', 'utf8', (err, data) => {
  console.log(data)
})
fs.readFile('c.txt', 'utf8', (err, data) => {
  console.log(data)
})
fs.readFile('d.txt', 'utf8', (err, data) => {
  console.log(data)
})
console.log('end')
```

+ 解决：代码嵌套

```js
const fs = require('fs')

console.log('begin')
// 读取文件a
fs.readFile('a.txt', 'utf8', (err, data) => {
  console.log(data)
  // 读取文件b
  fs.readFile('b.txt', 'utf8', (err, data) => {
    console.log(data)
    //读取文件c
    fs.readFile('c.txt', 'utf8', (err, data) => {
      console.log(data)
      // 读取文件d
      fs.readFile('d.txt', 'utf8', (err, data) => {
        console.log(data)
      })
    })
  })
})
```

缺点：回调函数嵌套过多，维护麻烦，称之为回调地狱



# 17-ES6-Promise语法-基本使用

+ promise的基本概念

```js
0. Promise 对象是 JavaScript 的异步操作解决方案
1. Promise是es6新增的一个构造函数
2. Promise:承诺，许诺
3. Promise是一个容器，这个容器中会放一个异步的任务，一个Promise对象，表示一个异步的任务

4. Promise的状态
	这个容器有三种状态：
    pending:   异步任务正在执行
	rejected： 异步任务执行失败
    fulfilled： 异步任务执行成功
5. promise的状态发生改变只会有两种情况   pending->rejected    pending->resolved
	状态一旦发生改变，就不会在修改，这个是Promise的由来，一旦承诺生效，就不会修改。
```



+ Promise的构造函数的使用

```js
// 读取文件
const fs = require('fs')
// promise构造函数的作用：创建一个promise对象，即一个异步任务的容器
const p1 = new Promise(function(resolve, reject) {
  fs.readFile('a.txt', 'utf8', (err, data) => {
    if (err) {
      // 失败
      reject(err)
    } else {
      // 成功
      resolve(data)
    }
  })
})
```

+ promise对象的使用

```js
// promise对象
// then方法表示成功 
// catch方法表示失败 
p1.then(function(data) { // 用于指定resolve
  console.log(data)
}).catch(function(err){ //用于指定reject
  console.log(err)
})
```

# 18-es6-promise-then方法

+ then方法会返回promise对象

```js
// promise的then方法会返回一个promise对象
p1.then(function(data) { 
  console.log('1')
}).then(function() {
  console.log('2')
}).then(function() {
  console.log('3')
}).then(function() {
  console.log('4')
})
```

+ then可以链式调用，第一个then的返回值会被第二个then的参数接收

```js
// promise的then方法会返回一个promise对象
p1.then(function(data) {
  //p1的resolve 
  console.log(data)
  // 如果在then中返回一个promise对象，
  // 那么第二个then的函数接收到的就是promise对象的resolve结果
  return p2
}).then(function(data) {
  //p2的resolve
  console.log(data)
})
```

# 19-es6-解决地狱回调问题

```js
// 读取文件
const fs =require('fs')
function readFile (path) {
  return new Promise(function(resolve, reject){
    fs.readFile(path, 'utf8', (err, data) => {
      if (err) {
        reject(err)
      } else {
        resolve(data)
      }
    })
  })
}

// 解决回调地狱问题
readFile('a.txt').then(data => {
  console.log(data)
  return readFile('b.txt')
}).then(data=> {
  console.log(data)
  return readFile('c.txt')
}).then(data => {
  console.log(data)
  return readFile('d.txt')
}).then(data => {
  console.log(data)
})
```





# 20-异步编程终极方案-async与await

异步终极解决方案：async， 可以以同步的方式来写异步的代码

+ 基本使用

```js
// async关键字用于描述一个函数
// 在async函数，可以使用await关键,不然会报错
async function fn () {
  let num = await 1
  let name = await 'zs'
  console.log(num, name)
}
fn()
```



+ 作用

```js
// await  操作符用于等待一个Promise 对象的结果
async function fn () {
  let result1 = await readFile('a.txt')
  let result2 = await readFile('b.txt')
  let result3 = await readFile('c.txt')
  let result4 = await readFile('d.txt')
  console.log(result1, result2, result3, result4)
}
fn()
```



+ axios的所有方法都支持promise，所有axios的方法都支持async函数

```js
async function getBrandList （） ｛
	const result = await axios.get('http://localhost:9999/getBrandList')
    console.log(result)
｝
```



+ 想想：在我们的项目中，使用async和await是不是很爽！！！



