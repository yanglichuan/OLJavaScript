<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
// ------------------
        // 交换两个值不需要第三方变量
        // var a = 5;
        // var b = -3;
        // a = a + b;
        // b = a - b;
        // a = a - b;
        // console.log(a + ", " + b);
// ------------------
        // javascript是弱类型语言，在编译中不确定数据类型，只有在运行时才知道。
        // var money = 12.3;
        // console.log(money);
// ------------------
        // 如果两边是number类型，则运算操作，如果有字符串参与，则两边都当做字符串来操作。
        // console.log(11+11);
        // console.log(11+"a");
// ------------------
        // 基本数据类型不可以toString，严格来说是没有函数调用
        // undefined.toString();  报错
        // 1.toString();  没有报错，此时1 已经被转换成对象了。
// ------------------
        // typeof null boolean number string undefined
        // typeof 判断基本数据类型除了null判断为object 其余的都可以判断，另外引用类型大多数为object类型。
        // console.log(typeof null); // object
// ------------------
        // 数据类型转换 字符串转数字，如果首字母是非数字则NaN 其余转到非数字为止。
        // var height = "12.3abc";
        // console.log(Number.parseInt(height));// 12
        // console.log(Number.parseFloat(height));//12.3
        // height = "bac12";
        // console.log(Number.parseInt(height)); // NaN

        // var isB = true; // 布尔类型无法转成数字
        // console.log(typeof isB + "  " + Number.parseInt(isB));
        // var ice = "-5"; // ±值也可以转数字
        // console.log(-ice);

        //转换成false的情况：null  undefined  ''空字符串  0 NaN
        // var a = null;
        // var b;
        // var c = "";
        // var d = [];
        // var e = NaN;
        // var f = 0;
        // console.log(Boolean(a));
        // console.log(Boolean(b));
        // console.log(Boolean(c));
        // console.log(Boolean(d)); // true 对象
        // console.log(Boolean(e));
        // console.log(Boolean(f));
// ------------------
        // == 值相等就true === 值相等而且类型也一致
        // var a = 10;
        // var b = 10;
        // var c = "10";
        // console.log(a == b); // true
        // console.log(a == c); // true
        // console.log(a === c); // false
// ------------------
        // 函数的定义分两种
        // 1. 声明函数(函数声明)
        // function sum(){
        //         console.log(1+1);
        //         return 1000;
        // }
        // // 2. 函数表达式
        // var add = function(a, b){
        //         return a + b;
        // }
// ------------------
        // function test(a, b, c) {
        //         // 我们可以通过arguments 获取函数调用的时候的实参
        //         // arguments非常像数组，但不是数组
        //         console.log(arguments);
        //         console.log(1);
        // }
        // test(4, 5, 6);

        // function getMax() {
        // var max = arguments[0];
        //      for (var i = 1; i < arguments.length; i++) {
        //              if (max < arguments[i]) {
        //              max = arguments[i];
        //              }
        //      }
        //      return max;
        // }
        // console.log(getMax(1, 3, 9, -3));

        // 3 自调用函数  -- 当函数书写完成之后立即调用
        // (function () {
        //         console.log('我是自调用函数');
        // })()

// ------------------
        // 块级作用域：在ECMAScript中没有块级作用域。
        // {
        //      var num = 12;
        // }
        // console.log(num);  // 这里依然可以访问
// ------------------
        // 预解析
    //    1 变量提升，把变量的声明提升到当前作用域的最上面，不包括变量的赋值
    //    2 函数提升，把函数的声明提升到当前作用域的最上面，不包括函数的调用
// ------------------
//         var a = 20;
//        function abc(){
//         console.log(a);
//         var a = 10;
//        }         
//        abc();
// ------------------
        // 对象的创建
        // 1. 对象字面量
        // var hero = {
        //      name: "黄忠",
        //      weapon: "弓箭",
        //      attack: function () {
        //              console.log(this.name + ", " + this.weapon);
        //      }
        // }
        // 2. new Object() 构造函数
        // var person = function(name, age) {
        //         this.name = name;
        //         this.age = age;
        // }
        // var p1 = new person("zs", 18);
        // 工厂方法
        // var createPerson = function(name, age) {
        //         var person = new Object();
        //         person.name = name;
        //         person.age = age;
        //         return person;
        // }
        // var p2 = createPerson("ls", 19);

        // 自定义构造函数
        // function Person(name, age) {
        //      this.name = name;
        //      this.age = age;   
        // }
// ------------------
        // this出现在以下位置，分别代表什么
        // 1 函数中   --  this 指向Window
        // 2 在方法中  --  this  指向的是这个方法所属的对象
        // 3 构造函数中  -- this 就是构造函数创建的对象
        // function fn(){
        //         console.log(this);
        // }
        // fn();

        // var obj = {
        //         name: 'zs',
        //         fn: function () {
        //                 console.log(this.name);
        //         }
        // };
        // obj.fn();

        // function Fn() {
        //         this.name = 'zs';
        //         this.age = 18;
        //         console.log(this);
        // }
        // var o = new Fn();  // 调用构造函数
        // Fn(); // 函数调用  ***
// ------------------
        // 遍历对象属性、删除属性、添加属性.
        // var obj = {
        //         name: 'zs',
        //         age: 18,
        //         sex: '男',
        //         sayHi: function () {
        //                 console.log(this.name + ': hello');
        //         }
        // };
        // for (let i=0; i<obj.ke) // 这种遍历不出来
        // for (const key in obj) {
        //         if (obj.hasOwnProperty(key)) {
        //                 const element = obj[key];
        //                 console.log(element);

        //         }
        // }

        // if (obj["name"] !== undefined) {
        //         console.log("非空");
        //         delete obj["name"]; // 删除属性
        // }
        // console.log(obj);
        // obj["name"] = "kitty";  // 添加属性并赋值
        // console.log(obj);
// ------------------
        // 工具中使用静态成员
        // 静态成员 ： 直接使用对象来调用的
        // MyMath.PI;
        // MyMath.max()
        // var MyMath = {
        //         PI: 3.1415926,
        //         max: function () {
        //         },
        //         min: function () {
        //         }
        // }
// ------------------
        // 数组排序
        // 默认情况下的sort是对字符编码 从小到大排序
        // var arr = [25, 10, 108, 18];
        // console.log(arr.sort()); // [10, 108, 18, 25]
        // console.log(arr.sort(function(a, b){return a - b})); //  [10, 18, 25, 108]
    
        // var a = Number(3);
        // console.log(typeof a);
// ------------------
        //  闭包与匿名函数的区别 
        //  闭包是指有权访问另一个函数作用域中的变量的函数 
        //  创建闭包的常见方式，就是在一个函数内部创建另一个函数 

        // 函数声明有函数提升
        // sayHi();
        // function sayHi(){
        //         console.log("sayHi");
        // }
        // 函数表达式没有函数提升，这样就报错了。
        // var sayHi = function(){
        //         console.log("sayHi");
        // }
        // sayHi();
// ------------------
        // function Person(name) {
        //         this.name = name;
        // }
        // var p = new Person("zs");
        // console.log(p);
        // console.log(p.constructor === Person);
        // // console.log(p.)
        
        // function parent2(age) {
        //         this.age = age;
        // }
        // var p2 = new parent2(18);
        // console.log(p2);
        // console.log(p2.constructor);
        // console.log(p2.constructor === parent2);
        // console.log(p2.constructor === Object);
// ------------------
        // 我们的第一个问题，为什么有的编程规范要求用 void 0 代替 undefined?现在我们就分别来看一下。
        // Undefined 类型表示未定义，它的类型只有一个值，就是 undefined。任何变量在赋值前是 Undefined 类型、值为 undefined，
        // 一般我们可以用全局变量 undefined(就是名为 undefined 的这个变量)来表达这个值，或者 void 运算来把任一一个表达式变成 
        // undefined 值。
        // 但是呢，因为 JavaScript 的代码 undefined 是一个变量，而并非是一个关键字，这是 JavaScript 语言公认的设计失误之一，
        // 所以，我们为了避免无意中被篡改，我 建议使用 void 0 来获取 undefined 值。
// ------------------
//     <!-- v-bind 只能实现数据的单向绑定，从 M 自动绑定到 V， 无法实现数据的双向绑定  -->
//     <!-- <input type="text" v-bind:value="msg" style="width:100%;"> -->

//     <!-- 使用  v-model 指令，可以实现 表单元素和 Model 中数据的双向数据绑定 -->
//     <!-- 注意： v-model 只能运用在 表单元素中 -->
//     <!-- input(radio, text, address, email....)   select    checkbox   textarea   -->


    </script>
</body>
</html>



